package com.zommer.core.first_part;


import java.util.ArrayList;
import java.util.List;

public class ProcedureJava {

    /**
     * Примитивные типы (value types)
     *      Знаковые числовые типы
     *          Целочисленные типы:
     *              литерал по умолчанию int
     *              byte 1 byte, short 2 bytes, int 4 bytes, long 8 bytes
     *          Числа с плавающей точкой:
     *              литерал по умолчанию - double
     *              float 4 bytes, double 8 bytes
     *
     *      Символьный тип:
     *          char 2 bytes представляет собой символ из кодировки UNICODE UTF-16
     *
     *      Булевский тип
     *          boolean - спецификация jvm не определяет однозначно размер переменной
     *          в hotspot - размер состовляет 4 bytes, в массивах преимущественно 1 byte
     *
     */
    public static void valueType() {
        byte b = 127;
        short sh = 32000;
        int i = 2_000_000_000;
        long l = 123L;

        float f = 12.3F;
        double d = 12.3;
        boolean bool = true;
    }

    /**
     *  Классы обертки (wrappers) - это иммутабельные классы, инкапсулирующие примитивные типы,
     * каждый примитивный тип имеет свой аналог.
     * Для чего?
     *      1) требуется работа с примитивом как с классом (методы)
     *      2) для работы с generic`ами
     *
     * Закешированные значения byte short int long
     *  Значения кешируются в интервале [-128; 127]
     *  Кешированные объекты не используются при создании wrapper с помощью конструктора
     *
     * Что такое пул интов?
     *  Пул объектов, значения которых лежат от [-128; 127]
     *  Можно расширить верхнюю границу значений пула xx:AutoBoxCacheMax=size
     *
     *
     * Autoboxing и Unboxing
     *      Autoboxing - процесс автоматического преобразования примитивного типа в класс Обертку
     *      Unboxing - процесс автоматического преобразования класса обертки в примитивный тип
     */
    public static void wrappers() {
        Byte b = 123;
        Short sh = 32000;
        Integer i = 2_000_000_000;
        Long l = 123L;

        Float f = 12.3F;
        Double d = 12.3;
        Boolean bool = true;

        List<Integer> list = new ArrayList<>();
        list.add(2);
        list.add(i);  // <--------- autoboxing
        int prim = i; // <--------- unboxing
    }


    /**
     * Преобразование - процесс приведения одонго типа к другому
     * Существует два типа приведения: расширение, сужение
     *      Расширение - приведение меньшего типа к большему
     *          переменной большего размера всегда можно присвоить переменную меньшего размера
     *      Сужение - приведение большего типа к меньшему
     *
     *      byte -> short -> int -> long -> float -> double
     *                       |-> float  |-> double
     *                       |-> double
     *
     *      Явное приведение типов требуется в случае сужения типа,
     *      т.к. при присваивании переменной меньшего размера переменную большего теряются данные (переполнение),
     *      отсекаются ведущие биты по сути деление по модулю
     */
    public static void casting() {

        // upcasting
        byte b = 123;
        short sh = 2000;
        int i = 2_000_000;
        long l = 123L;

        float f = 12.f;
        double d = 12.3;

        //неявно
        l = b;
        l = sh;
        l = i;

        f = l;
        d = f;
        d = l;

        //явно
        int explicit = (int) 123L;
    }

    /**
     * Строки - объекты класса String
     *  строки иммутабельны, от самого класса нельзя наследоваться
     *  лююбые операции над строкой возвращают новую строку, изначальное значение не меняется
     *  оператор == сравнивает строки по ссылке,
     *  чтобы сравнивать строки по содержанию надо использовать метод equals
     *
     *  пул строк - это место памяти в куче, где хранятся ранее использованные литералы строк
     *  в пул заносятся значения при инициализации и с помощью метода intern()
     *  В пул не заносятся значения, которые созданы с помощью оператор new
     *
     *  Т.к. строки имутабельны, то каждое изменение влечет за собой создание новой строки,
     *  Допустим строка из миллиарда символов, если стоит задача поменять каждый символ на что-то отличное,
     *  то при каждом изменении будет создаваться новая строка.
     *
     *  StringBuffer
     *  является мутабельным классом, каждое изменение не приводит к созданию новой строки,
     *  является потокобезопасным, все методы являются синхронными
     *  Каждый объет StringBuffer имеет свою capacity, по умолчанию 16
     *  capacity можно задать явно через конструктор
     *
     *  StringBuilder
     *  является мутабельным классом, каждое изменение не приводит к созданию новой строки,
     *  не является потокобезопасным.
     *  Подходит для однопоточных приложений, работает быстрее StringBuffer
     */
    public static void strings() {
        String s = "asd";
        String s1 = "asd";

        System.out.println(s == s1);
        StringBuffer sb = new StringBuffer();

        String domain = ".ru";
        StringBuffer buffer = new StringBuffer("zommer");
        buffer.append(domain);
        buffer.delete(0, 6);
        buffer.insert(0, "zommer");
    }

    public static void test(Appendable obj) throws java.io.IOException {
        // узнаем текущее время до теста
        long before = System.currentTimeMillis();
        for (int i = 0; i < 1e9; i++) {
            obj.append("");
        }
        // узнаем текущее время после теста
        long after = System.currentTimeMillis();
        // выводим результат
        System.out.println(obj.getClass().getSimpleName() + ": " + (after - before) + "ms.");
    }

    /**
     * Почему не рекомендуется использовать?
     *  Строка незименяемый и кешируемый объект. Строковый литерал будет в памяти до тех пор,
     *  пока сборщик мусора их не соберет
     *
     * Почему String неизменяемый final класс
     *  такие ограничения дают гарантии безопасности
     *  1) передача между потоками
     *  2) отсутсвие утечек памяти
     *  3) возможность кешировать
     *
     * Почему строка является популярным ключом в HashMap
     *  Потмоу что строка неизменяемый объект - это дает прирост в производительности,
     *  т.к. нет необходимости считать хэш более одного раза.
     *
     * Можно ли использовать строки в конструкции switch?
     *  Да, начиная с java 7. Преобразует в хеш и использует для оператора switch
     *
     * Какая основная разница между String, StringBuffer, StringBuilder
     *  String - имутабельный класс, остальные два мутабельные
     *
     * Существуют ли в java многомерные массивы?
     *  Да, массивы массивов
     *
     * Какими значениями инициализируются переменные по умолчанию?
     *  Если речь про локальные, то никакими.
     *      при попытке получить перемеенную компилятор выдаст ошибку, что переменная не инициализварона
     *  Если речь про переменные класса, то
     *      примитивные типы - 0 boolean = false
     *      ссылочные типы - null
     *
     * Что такое сигнатура метода?
     *  совокупность имени метода и его параметров
     *  Пример: {@code method(double, int)}
     *
     * Что такое метод main?
     *  метод, который является точкой входа в программу
     *  модификатор public чтобы jre могла найти этот метод
     *  модификатор static поскольку при запуске программы объект еще не создан
     *  возвращаемый тип void
     *
     * Переменные всегда передаются по значению.
     *  Примитивные типы: само значение
     *  Ссылочные тип: передача скопированной сылки
     */
}
